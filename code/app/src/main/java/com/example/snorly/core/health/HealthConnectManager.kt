package com.example.snorly.core.health

import android.content.Context
import android.util.Log
import androidx.health.connect.client.HealthConnectClient
import androidx.health.connect.client.permission.HealthPermission
import androidx.health.connect.client.records.SleepSessionRecord
import androidx.health.connect.client.request.ReadRecordsRequest
import androidx.health.connect.client.time.TimeRangeFilter
import java.time.Instant
import java.time.ZoneId

class HealthConnectManager(private val context: Context) {

    // SAFE AVAILABILITY CHECK
    // This allows us to check status without crashing or initializing the heavy client
    fun isHealthConnectAvailable(): Boolean {
        return try {
            // SDK_AVAILABLE is a constant int (usually 1 or 2 depending on version)
            HealthConnectClient.getSdkStatus(context) == HealthConnectClient.SDK_AVAILABLE
        } catch (e: Exception) {
            // On very old devices, even the class check might fail
            false
        }
    }

    // This is the actual entry point to the Google API.
    // We get it efficiently using getOrCreate.
    private val healthConnectClient: HealthConnectClient? by lazy {
        try {
            if (isHealthConnectAvailable()) {
                HealthConnectClient.getOrCreate(context)
            } else {
                null
            }
        } catch (e: Exception) {
            // Log the error but DO NOT CRASH
            Log.e("HealthConnectManager", "Health Connect not available: ${e.message}")
            null
        }
    }

    // Define Permissions
    // We need to tell the system exactly what data types we want to touch.
    val permissions = setOf(
        HealthPermission.getReadPermission(SleepSessionRecord::class),
        HealthPermission.getWritePermission(SleepSessionRecord::class)
    )


    suspend fun writeSleepSessionReturningId(start: Instant, end: Instant): String? {
        val client = healthConnectClient ?: return null
        return try {
            val record = SleepSessionRecord(
                startTime = start,
                startZoneOffset = ZoneId.systemDefault().rules.getOffset(start),
                endTime = end,
                endZoneOffset = ZoneId.systemDefault().rules.getOffset(end)
            )
            val response = client.insertRecords(listOf(record))
            // Return the new UID generated by Health Connect
            response.recordIdsList.firstOrNull()
        } catch (e: Exception) {
            Log.e("HealthConnectManager", "Error writing sleep: ${e.message}")
            null
        }
    }

    // Check if we have permission
    // We call this before trying to read data.
    suspend fun hasAllPermissions(): Boolean {
        return healthConnectClient?.permissionController?.getGrantedPermissions()
            ?.containsAll(permissions) == true
    }

    // WRITE (Add manually)
    suspend fun writeSleepSession(start: Instant, end: Instant) {
        val client = healthConnectClient ?: return

        // Basic record without stages for manual entry
        // (Manual entry usually doesn't have REM/Deep data unless you are a wizard)
        val record = SleepSessionRecord(
            startTime = start,
            startZoneOffset = ZoneId.systemDefault().rules.getOffset(start),
            endTime = end,
            endZoneOffset = ZoneId.systemDefault().rules.getOffset(end)
        )

        client.insertRecords(listOf(record))
    }

    //Read Sleep Data
    // "suspend" means this runs in the background (Coroutines) so the UI doesn't freeze.
    // "start" and "end" define the time window we want to look at.
    suspend fun readSleepSessions(start: Instant, end: Instant): List<SleepSessionRecord> {
        // If client is null, just return empty list
        val client = healthConnectClient ?: return emptyList()

        return try {
            // A. Create the request
            // We ask for records of type 'SleepSessionRecord' within the time range.
            val request = ReadRecordsRequest(
                recordType = SleepSessionRecord::class,
                timeRangeFilter = TimeRangeFilter.between(start, end)
            )

            val response = client.readRecords(request)

            // Return the list of records found
            response.records
        } catch (e: Exception) {
            // Log errors (e.g., user revoked permission, Health Connect not installed)
            Log.e("HealthConnectManager", "Error reading sleep: ${e.message}")
            emptyList()
        }
    }

    // UPDATE (Edit existing)
    suspend fun updateSleepSession(record: SleepSessionRecord) {
        val client = healthConnectClient ?: return
        try {
            client.updateRecords(listOf(record))
        } catch (e: Exception) {
            android.util.Log.e("HealthConnect", "Failed to update: ${e.message}")
        }
    }

    // Delte Sleep Data
    suspend fun deleteSleepSession(uid: String) {
        val client = healthConnectClient ?: return
        try {
            // We delete by the unique ID of the record
            client.deleteRecords(
                SleepSessionRecord::class,
                recordIdsList = listOf(uid),
                clientRecordIdsList = emptyList()
            )
        } catch (e: Exception) {
            android.util.Log.e("HealthConnect", "Failed to delete: ${e.message}")
        }
    }
    // Read Sleep Data by ID for sleep details view
suspend fun readRecordById(uid: String): SleepSessionRecord? {
    val client = healthConnectClient ?: return null

    return try {
        // Use the direct readRecord method for IDs
        val response = client.readRecord(
            recordType = SleepSessionRecord::class,
            recordId = uid
        )
        response.record
    } catch (e: Exception) {
        Log.e("HealthConnectManager", "Error reading record by ID: ${e.message}")
        null
    }
}
}