<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Snorly – Project Documentation</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <style>
    body {
      font-family: Arial, Helvetica, sans-serif;
      margin: 0;
      padding: 0;
      background-color: #0f172a;
      color: #e5e7eb;
      line-height: 1.6;
    }

    header {
      background: linear-gradient(135deg, #4f46e5, #06b6d4);
      padding: 40px 20px;
      text-align: center;
      color: white;
    }

    header h1 {
      margin: 0;
      font-size: 3rem;
    }

    header p {
      margin-top: 10px;
      font-size: 1.2rem;
      max-width: 800px;
      margin-left: auto;
      margin-right: auto;
    }

    main {
      max-width: 900px;
      margin: 0 auto;
      padding: 30px 20px 60px;
    }

    .card {
      background-color: #020617;
      border-radius: 12px;
      padding: 24px;
      margin-bottom: 24px;
      box-shadow: 0 0 20px rgba(0,0,0,0.3);
    }

    h2 {
      border-bottom: 1px solid #1e293b;
      padding-bottom: 8px;
    }

    ul { padding-left: 20px; }
    li { margin-bottom: 8px; }

    a { color: #38bdf8; text-decoration: none; }
    a:hover { text-decoration: underline; }

    .muted {
      color: #94a3b8;
      margin-top: -6px;
    }

    .prototype-grid {
      margin-top: 16px;
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
      gap: 16px;
    }

    .prototype-grid figure {
      margin: 0;
      background: #0b1224;
      border: 1px solid #1e293b;
      border-radius: 12px;
      overflow: hidden;
      box-shadow: 0 0 18px rgba(0,0,0,0.25);
    }

    .prototype-grid img { width: 100%; height: auto; display: block; }

    .prototype-grid figcaption {
      padding: 12px 14px;
      font-size: 0.95rem;
      color: #cbd5e1;
    }

    .badge {
      display: inline-block;
      padding: 4px 10px;
      border-radius: 999px;
      background: #0b1224;
      border: 1px solid #1e293b;
      color: #cbd5e1;
      font-size: 0.85rem;
      margin-top: 6px;
    }

    /* ✅ Charts layout */
    .results-grid {
      margin-top: 14px;
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      gap: 16px;
    }

    .chart-card {
      background: #0b1224;
      border: 1px solid #1e293b;
      border-radius: 12px;
      padding: 14px;
      box-shadow: 0 0 18px rgba(0,0,0,0.25);
    }

    .chart-title {
      margin: 0 0 6px 0;
      font-size: 1rem;
      color: #e5e7eb;
    }

    .chart-subtitle {
      margin: 0 0 10px 0;
      font-size: 0.9rem;
      color: #94a3b8;
    }

    .chart-wrap {
      width: 100%;
      overflow-x: auto;
      border-radius: 10px;
    }

    svg.chart {
      width: 100%;
      height: auto;
      display: block;
      background: #020617;
      border: 1px solid #1e293b;
      border-radius: 10px;
    }

    .small-note {
      margin-top: 10px;
      font-size: 0.85rem;
      color: #94a3b8;
    }

    /* ✅ Table */
    .table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 12px;
      font-size: 0.95rem;
    }
    .table th, .table td {
      border-bottom: 1px solid #1e293b;
      padding: 10px 8px;
      text-align: left;
      vertical-align: top;
    }
    .table th { color: #cbd5e1; font-weight: 600; }
    .table td { color: #e5e7eb; }

    footer {
      text-align: center;
      padding: 20px;
      color: #94a3b8;
      font-size: 0.9rem;
    }
  </style>
</head>
<body>

  <header>
    <h1>Snorly</h1>
    <p>Sleep Tracker & Alarm Clock App</p>
  </header>

  <main>

    <!-- PROJECT DETAILS -->
    <div class="card">
      <h2>Project Details</h2>

      <h3>Name of the Solution</h3>
      <p><strong>Snorly</strong></p>

      <h3>Brief Description</h3>
      <p>
        Snorly is a smart sleep tracker and alarm clock app designed to help users wake up more easily and improve their sleep habits.
        The app tracks sleep duration and sleep quality during the night and presents the data in a simple and easy-to-understand way.
      </p>
      <p>
        To prevent users from oversleeping, Snorly uses interactive puzzles that must be solved to turn off the alarm.
        These puzzles help wake up the brain and make sure the user is fully awake before the alarm stops.
      </p>
      <p>
        Snorly is designed for students and busy people who struggle to wake up on time and want to build healthier sleep routines.
      </p>

      <h3>Team Members</h3>
      <ul>
        <li>Pesendorfer Lukas</li>
        <li>Tuerk Laurens</li>
      </ul>
    </div>

    <!-- APP DEVELOPMENT DOCUMENTATION -->
    <div class="card">
      <h2>Documentation of App Development</h2>

      <h3>App Concept</h3>
      <p>
        A combined sleep-tracking and alarm app that provides sleep insights and supports waking up reliably.
        The core differentiator is puzzle-based alarm dismissal to reduce oversleeping and improve alertness.
      </p>

      <h3>Use Case</h3>
      <p>
        Users set one or multiple alarms, track their sleep during the night, and review reports to understand sleep duration and quality.
        In the morning, the alarm can include a puzzle challenge to ensure the user is fully awake before turning it off.
      </p>

      <h3>Target User</h3>
      <p>
        Snorly is mainly designed for students and busy people who often oversleep, struggle with waking up on time,
        and want a simple way to improve sleep habits with clear insights and routines.
      </p>

      <h3>Hi-fi Prototype (User Flow)</h3>
      <p class="muted">Add your high-fidelity prototype screens and a clear user flow here.</p>

      <div class="prototype-grid">
        <figure>
          <img src="images/prototype.png" alt="Snorly prototype screens (Alarm, Sleep, Report, Settings)" />
          <figcaption>
            Prototype overview: Alarm setup, sleep tracking dashboard, sleep reports, and settings.
          </figcaption>
        </figure>
        <!--
        <figure>
          <img src="images/userflow.png" alt="Snorly user flow diagram" />
          <figcaption>
            User flow: Set alarm → Start sleep tracking → Alarm rings → Solve puzzle → View report.
          </figcaption>
        </figure>
        -->
      </div>

      <h3>SQLite Database Design (ERD)</h3>
      <p class="muted">Placeholder — add your ERD image here when ready.</p>
      <span class="badge">TODO: Add ERD image (e.g., images/erd.png)</span>

      <h3>Repository (Source Code)</h3>
      <p class="muted">Replace the link below with your GitHub repository URL.</p>
      <ul>
        <li><a href="#" target="_blank" rel="noopener">GitHub Repository Link (TODO)</a></li>
      </ul>

      <h3>APK Download</h3>
      <p class="muted">Put the APK into a visible folder (e.g., /apk/) and link it here.</p>
      <ul>
        <li><a href="#" download>Download APK (TODO: link your APK file)</a></li>
      </ul>
      <span class="badge">Example path: apk/Snorly.apk</span>
    </div>

    <!-- FINAL REFLECTIONS -->
    <div class="card">
      <h2>Final Reflection</h2>

      <h3>Pesendorfer Lukas</h3>
      <ul>
        <li><strong>Challenges:</strong>
          Choosing and correctly implementing the required Android permissions (especially around alarms/notifications and background behavior).
          Another major challenge was managing multiple UI states across different screens in Jetpack Compose and making sure they stay consistent when returning to the main screen.
          Finally, it was challenging to persist those states reliably by mapping them into SQLite (designing the right structure and ensuring updates were saved correctly).
        </li>
        <li><strong>My Contribution:</strong>
          I implemented the full alarm feature, including alarm creation and configuration, and the puzzle/challenge-based dismissal flow.
          This includes the logic for triggering the alarm, handling the dismissal interaction, and connecting the related settings/state to the app’s data flow.
        </li>
        <li><strong>Concept vs Final App:</strong>
          The final app matches the initial concept well: it combines sleep tracking with an alarm that uses interactive challenges to prevent oversleeping.
          The alarm-and-challenge interaction remained the core idea and is implemented as a working feature in the MVP.
        </li>
        <li><strong>Possible Improvements:</strong>
          Add more challenge types (and more difficulty options) so users can choose what works best for them.
          Also add theme changes based on time of day (e.g., calmer night theme, brighter morning theme) to improve readability and overall experience.
        </li>
      </ul>

      <h3>Tuerk Laurens</h3>
      <ul>
        <li><strong>Challenges:</strong> <span class="muted">TODO</span></li>
        <li><strong>My Contribution:</strong> <span class="muted">TODO</span></li>
        <li><strong>Concept vs Final App:</strong> <span class="muted">TODO</span></li>
        <li><strong>Possible Improvements:</strong> <span class="muted">TODO</span></li>
      </ul>
    </div>

    <!-- USABILITY TEST DOCUMENTATION -->
    <div class="card">
      <h2>Documentation of Usability Test</h2>

      <h3>Usability Test Plan & Heuristic Evaluation</h3>

      <h3 style="margin-top: 18px;">Part 1: Heuristic Evaluation</h3>
      <p><strong>Methodology:</strong> Nielsen’s 10 Usability Heuristics</p>
      <p><strong>Scope:</strong> Initial MVP Prototype (Android / Jetpack Compose)</p>
      <p><strong>Evaluators:</strong> Team Snorly</p>

      <h4>1) Description of the Evaluation</h4>
      <p>
        We examined the interface against Jakob Nielsen's usability heuristics to identify usability problems before user testing.
        We focused on the critical paths: Setting an alarm, Sleep Tracking, and Puzzle Dismissal.
      </p>

      <h4>2) Results (Heuristic Violations & Severity)</h4>
      <p class="muted">Severity scale: 0 (No problem) to 4 (Usability catastrophe)</p>

      <h4>A. Visibility of System Status (Heuristic #1)</h4>
      <ul>
        <li><strong>Finding:</strong> When "Sleep Tracking" is active, there is no clear indication outside the app (e.g., notification bar) that the app is running.</li>
        <li><strong>Impact:</strong> Users might think tracking stopped if they minimize the app.</li>
        <li><strong>Severity:</strong> 3 (Major)</li>
        <li><strong>Recommendation:</strong> Implement a persistent notification or a distinct “Recording” animation on the TopAppBar while tracking is active.</li>
      </ul>

      <h4>B. User Control and Freedom (Heuristic #3)</h4>
      <ul>
        <li><strong>Finding:</strong> While the "Puzzle Alarm" intends to restrict control, there is no emergency dismiss (e.g., long press for 10 seconds) in case of a bug or a sensitive real-world context.</li>
        <li><strong>Impact:</strong> Users may force-close or uninstall the app if they cannot stop the alarm in an inappropriate setting.</li>
        <li><strong>Severity:</strong> 2 (Minor / Strategic)</li>
        <li><strong>Recommendation:</strong> Keep the puzzle, but consider allowing a more accessible snooze, while keeping “Dismiss” hard.</li>
      </ul>

      <h4>C. Error Prevention (Heuristic #5)</h4>
      <ul>
        <li><strong>Finding:</strong> In the “Set Alarm” dialog, the AM/PM toggle (if using 12h format) is small or too close to the “Save” button.</li>
        <li><strong>Impact:</strong> Users might accidentally set an alarm for 7:00 PM instead of 7:00 AM.</li>
        <li><strong>Severity:</strong> 4 (Catastrophe — failed core value)</li>
        <li><strong>Recommendation:</strong> Use a 24h clock by default or make AM/PM very distinct. Add a “Time until alarm” confirmation (e.g., “Alarm set for 8 hours from now”).</li>
      </ul>

      <h4>D. Recognition Rather Than Recall (Heuristic #6)</h4>
      <ul>
        <li><strong>Finding:</strong> Puzzle difficulty is labeled “Easy/Medium/Hard”, but there is no preview of what “Medium” looks like until the alarm rings.</li>
        <li><strong>Impact:</strong> Users have to guess if they can solve it while groggy.</li>
        <li><strong>Severity:</strong> 2 (Minor)</li>
        <li><strong>Recommendation:</strong> Add a “Preview Puzzle” button on the Settings screen.</li>
      </ul>

      <h3 style="margin-top: 24px;">Part 2: User Test Plan (Lab/Field Test)</h3>

      <h4>1) Hypotheses & Testable Questions</h4>
      <ul>
        <li><strong>Hypothesis A:</strong> Users using the “Puzzle” dismissal method will demonstrate higher cognitive alertness immediately after dismissal compared to standard “Swipe” dismissal.</li>
        <li><strong>Hypothesis B:</strong> Users will perceive the “Math” puzzle as more effective but more frustrating than the “Memory” puzzle.</li>
        <li><strong>Testable question:</strong> Does the friction introduced by the puzzle cause users to force-close the app rather than solve the puzzle?</li>
      </ul>

      <h4>2) Planned Data to Collect (Variables)</h4>
      <p><strong>Independent Variables</strong></p>
      <ul>
        <li>Dismissal Type: Standard Swipe vs. Math Puzzle vs. Memory Puzzle</li>
        <li>Context: Testing during the day (simulated nap) vs. morning (real use)</li>
      </ul>

      <p><strong>Dependent Variables</strong></p>
      <ol>
        <li><strong>Time to Dismiss (Quantitative):</strong> Time in seconds from alarm start to successful dismissal</li>
        <li><strong>Error Rate (Quantitative):</strong> Failed attempts or accidental “Snooze” taps</li>
        <li><strong>Force Close Rate (Quantitative):</strong> Did the user kill the app instead of solving?</li>
        <li><strong>Subjective Alertness (Qualitative):</strong> Self-reported (1–5) “How awake do you feel?”</li>
        <li><strong>User Satisfaction (Qualitative):</strong> System Usability Scale (SUS)</li>
      </ol>

      <h4>3) Methods & Protocol (Tasks & Materials)</h4>
      <p><strong>Participants:</strong> 3–5 students (hallway testing / fellow students)</p>
      <p><strong>Materials:</strong></p>
      <ul>
        <li>Smartphone with MVP app installed</li>
        <li>Observation sheet (spreadsheet)</li>
        <li>SUS questionnaire (Google Forms)</li>
        <li>Post-test questionnaire (Google Forms)</li>
      </ul>

      <p><strong>Task List (Script):</strong></p>
      <ul>
        <li><strong>Task 1: Setup (Onboarding)</strong>
          <ul>
            <li><strong>Prompt:</strong> “Open the app for the first time. Set up an alarm for 2 minutes from now. Choose a ‘Math’ puzzle as your wake-up requirement.”</li>
            <li><strong>Observation focus:</strong> Can they find the settings?</li>
          </ul>
        </li>
        <li><strong>Task 2: The Sleep Simulation</strong>
          <ul>
            <li><strong>Prompt:</strong> “Start the sleep tracking feature and lock the phone. Wait for the alarm.”</li>
            <li><strong>Observation focus:</strong> Do they know how to start sleep tracking? Does the app stay active?</li>
          </ul>
        </li>
        <li><strong>Task 3: The Wake Up</strong>
          <ul>
            <li><strong>Prompt:</strong> “When the alarm rings, turn it off completely.”</li>
            <li><strong>Observation focus:</strong> Watch their fingers. Do they struggle with touch targets? Do they try to swipe it away out of habit?</li>
          </ul>
        </li>
      </ul>
    </div>

    <!-- USER TEST RESULTS (REAL DATA + BOXPLOTS + CHARTS) -->
    <div class="card" id="user-test-results">
      <h2>User Test Results</h2>
      <p class="muted">
        The charts below are generated from our collected data (demographics, questionnaire, and SUS).
        (Note: task completion time was not collected in these files — add it later if you have an observation sheet.)
      </p>

      <h3>Participants (Count & Demographics)</h3>
      <p>
        <strong>Count:</strong> <span id="participants-count">—</span><br />
        <strong>Gender:</strong> <span id="participants-gender">—</span><br />
        <strong>Age:</strong> <span id="participants-age">—</span>
      </p>

      <div class="results-grid">
        <!-- Boxplot: SUS -->
        <div class="chart-card">
          <p class="chart-title">Boxplot: SUS Score (0–100)</p>
          <p class="chart-subtitle">Median + quartiles + whiskers + participant dots</p>
          <div class="chart-wrap">
            <svg class="chart" id="svg-box-sus" viewBox="0 0 760 280" role="img" aria-label="Boxplot for SUS scores"></svg>
          </div>
          <p class="small-note" id="note-box-sus"></p>
        </div>

        <!-- Boxplot: App Structure -->
        <div class="chart-card">
          <p class="chart-title">Boxplot: App Structure Rating (1–5)</p>
          <p class="chart-subtitle">Question: “How do you find the app structure?”</p>
          <div class="chart-wrap">
            <svg class="chart" id="svg-box-structure" viewBox="0 0 760 280" role="img" aria-label="Boxplot for app structure rating"></svg>
          </div>
          <p class="small-note" id="note-box-structure"></p>
        </div>

        <!-- Bar: Puzzle difficulty appropriate -->
        <div class="chart-card">
          <p class="chart-title">Puzzle Difficulty Appropriate?</p>
          <p class="chart-subtitle">Yes vs No counts</p>
          <div class="chart-wrap">
            <svg class="chart" id="svg-bar-puzzle" viewBox="0 0 760 280" role="img" aria-label="Bar chart for puzzle difficulty feedback"></svg>
          </div>
          <p class="small-note" id="note-bar-puzzle"></p>
        </div>

        <!-- Bar: Ages -->
        <div class="chart-card">
          <p class="chart-title">Participant Ages</p>
          <p class="chart-subtitle">Age distribution (bars by participant)</p>
          <div class="chart-wrap">
            <svg class="chart" id="svg-bar-age" viewBox="0 0 760 280" role="img" aria-label="Bar chart for participant ages"></svg>
          </div>
          <p class="small-note" id="note-bar-age"></p>
        </div>
      </div>

      <h3>Quantitative Summary (Table)</h3>
      <table class="table" aria-label="User test quantitative summary">
        <thead>
          <tr>
            <th>Participant</th>
            <th>Gender</th>
            <th>Age</th>
            <th>App Structure (1–5)</th>
            <th>Puzzle Difficulty OK?</th>
            <th>SUS Score (0–100)</th>
          </tr>
        </thead>
        <tbody id="summary-table-body"></tbody>
      </table>

      <h3>Most Relevant Feedback Excerpts</h3>
      <ul id="feedback-excerpts"></ul>

      <h3>Updates Made Based on Feedback</h3>
      <ul>
        <li class="muted">TODO: e.g., improve navigation clarity, make alarm creation easier to discover, add puzzle preview, etc.</li>
      </ul>
    </div>

    <!-- DOCUMENTATION INDEX -->
    <div class="card">
      <h2>Documentation Index</h2>
      <ul>
        <li><a href="#">Day 1 – Project Idea & Planning</a></li>
        <!-- Add new days here -->
      </ul>
    </div>

  </main>

  <footer>
    Snorly Project Documentation — CCL 2025
  </footer>

  <script>
    /**
     * ✅ Data pasted from your CSVs (User data + Questionares + SUS).
     * If you re-export later, just update this array.
     */
    const participants = [
      { pid: "P1", gender: "Male", age: 24, appStructure: 4, puzzleAppropriate: "no",  firstLook: "adding an alarm",         susScore: 87.5 },
      { pid: "P2", gender: "Male", age: 22, appStructure: 3, puzzleAppropriate: "yes", firstLook: "Alarm",                    susScore: 100.0 },
      { pid: "P3", gender: "Male", age: 23, appStructure: 3, puzzleAppropriate: "yes", firstLook: "Alarm clock",              susScore: 100.0 },
      { pid: "P4", gender: "Male", age: 22, appStructure: 1, puzzleAppropriate: "yes", firstLook: "navigation",               susScore: 100.0 },
      { pid: "P5", gender: "Male", age: 21, appStructure: 1, puzzleAppropriate: "yes", firstLook: "How to set an alarm",      susScore: 82.5 },
      { pid: "P6", gender: "Male", age: 36, appStructure: 1, puzzleAppropriate: "yes", firstLook: "alarm how it looks like",  susScore: 97.5 }
    ];

    // ---------- utilities ----------
    const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
    const fmt = (n, d=1) => Number(n).toFixed(d);

    function median(sorted) {
      const n = sorted.length;
      if (!n) return NaN;
      const mid = Math.floor(n / 2);
      return (n % 2 === 0) ? (sorted[mid - 1] + sorted[mid]) / 2 : sorted[mid];
    }

    function quartiles(values) {
      const v = values.slice().sort((a,b)=>a-b);
      if (!v.length) return null;

      const med = median(v);
      const mid = Math.floor(v.length / 2);
      const lower = v.slice(0, mid);
      const upper = (v.length % 2 === 0) ? v.slice(mid) : v.slice(mid + 1);

      const q1 = median(lower.length ? lower : v);
      const q3 = median(upper.length ? upper : v);

      const iqr = q3 - q1;
      const lowFence = q1 - 1.5 * iqr;
      const highFence = q3 + 1.5 * iqr;

      let wLow = v[0], wHigh = v[v.length - 1];
      for (let i = 0; i < v.length; i++) { if (v[i] >= lowFence) { wLow = v[i]; break; } }
      for (let i = v.length - 1; i >= 0; i--) { if (v[i] <= highFence) { wHigh = v[i]; break; } }

      const outliers = v.filter(x => x < wLow || x > wHigh);
      return { q1, med, q3, iqr, wLow, wHigh, outliers, sorted: v, min: v[0], max: v[v.length-1] };
    }

    function stats(values) {
      const v = values.map(Number).filter(x => !Number.isNaN(x));
      if (!v.length) return null;
      const min = Math.min(...v);
      const max = Math.max(...v);
      const mean = v.reduce((a,b)=>a+b,0) / v.length;
      return { n: v.length, min, max, mean };
    }

    // ---------- SVG helpers ----------
    function svgEl(tag, attrs = {}, children = []) {
      const el = document.createElementNS("http://www.w3.org/2000/svg", tag);
      for (const [k, v] of Object.entries(attrs)) el.setAttribute(k, String(v));
      for (const c of children) el.appendChild(c);
      return el;
    }

    function clearSvg(svg) {
      while (svg.firstChild) svg.removeChild(svg.firstChild);
    }

    function textEl(x, y, str, opts = {}) {
      return svgEl("text", {
        x, y,
        fill: opts.fill ?? "#cbd5e1",
        "font-size": opts.size ?? 12,
        "font-weight": opts.weight ?? "400",
        "text-anchor": opts.anchor ?? "start",
        "dominant-baseline": opts.baseline ?? "alphabetic",
      }, [document.createTextNode(str)]);
    }

    function lineEl(x1,y1,x2,y2, opts={}) {
      return svgEl("line", {
        x1, y1, x2, y2,
        stroke: opts.stroke ?? "#1e293b",
        "stroke-width": opts.w ?? 2,
        "stroke-linecap": "round"
      });
    }

    function rectEl(x,y,w,h, opts={}) {
      return svgEl("rect", {
        x, y, width: w, height: h,
        rx: opts.rx ?? 10, ry: opts.ry ?? 10,
        fill: opts.fill ?? "rgba(79,70,229,0.22)",
        stroke: opts.stroke ?? "#4f46e5",
        "stroke-width": opts.sw ?? 2
      });
    }

    function circleEl(cx,cy,r, opts={}) {
      return svgEl("circle", {
        cx, cy, r,
        fill: opts.fill ?? "rgba(6,182,212,0.85)",
        stroke: opts.stroke ?? "#06b6d4",
        "stroke-width": opts.sw ?? 1
      });
    }

    // ---------- single boxplot (1 distribution) ----------
    function drawSingleBoxplot(svgId, values, valueLabel, noteId, domainOverride=null) {
      const svg = document.getElementById(svgId);
      if (!svg) return;
      clearSvg(svg);

      const W = 760, H = 280;
      const pad = { l: 60, r: 20, t: 20, b: 44 };
      const plotW = W - pad.l - pad.r;

      const vals = values.map(Number).filter(x => !Number.isNaN(x));
      const q = quartiles(vals);
      if (!q) return;

      let minV = q.min, maxV = q.max;
      if (domainOverride) { minV = domainOverride[0]; maxV = domainOverride[1]; }
      const range = (maxV - minV) || 1;
      const minA = minV - range * 0.05;
      const maxA = maxV + range * 0.05;

      const xScale = (v) => pad.l + ((v - minA) / (maxA - minA)) * plotW;
      const y = 120;

      // grid + ticks
      const ticks = 6;
      for (let i = 0; i <= ticks; i++) {
        const v = minA + (i / ticks) * (maxA - minA);
        const x = xScale(v);
        svg.appendChild(lineEl(x, pad.t, x, H - pad.b, { stroke: "#111827", w: 1 }));
        svg.appendChild(textEl(x, H - 18, fmt(v, valueLabel === "App Structure (1–5)" ? 1 : 0), {
          anchor: "middle", size: 11, fill: "#94a3b8"
        }));
      }

      svg.appendChild(textEl(pad.l, 14, valueLabel, { size: 12, fill: "#94a3b8" }));

      // whisker
      svg.appendChild(lineEl(xScale(q.wLow), y, xScale(q.wHigh), y, { stroke: "#cbd5e1", w: 2 }));
      svg.appendChild(lineEl(xScale(q.wLow), y - 12, xScale(q.wLow), y + 12, { stroke: "#cbd5e1", w: 2 }));
      svg.appendChild(lineEl(xScale(q.wHigh), y - 12, xScale(q.wHigh), y + 12, { stroke: "#cbd5e1", w: 2 }));

      // box
      const boxH = 44;
      const x1 = xScale(q.q1);
      const x3 = xScale(q.q3);
      svg.appendChild(rectEl(x1, y - boxH/2, Math.max(2, x3 - x1), boxH, {
        fill: "rgba(79,70,229,0.22)",
        stroke: "#4f46e5",
        sw: 2,
        rx: 12,
        ry: 12
      }));

      // median
      svg.appendChild(lineEl(xScale(q.med), y - boxH/2, xScale(q.med), y + boxH/2, { stroke: "#06b6d4", w: 3 }));

      // points (jitter)
      vals.forEach((v, i) => {
        const jy = y + (Math.random() - 0.5) * 26;
        svg.appendChild(circleEl(xScale(v), jy, 5));
      });

      // outliers
      q.outliers.forEach(v => svg.appendChild(circleEl(xScale(v), y, 6, { fill: "rgba(229,231,235,0.9)", stroke: "#e5e7eb", sw: 1 })));

      // note
      const st = stats(vals);
      const noteEl = document.getElementById(noteId);
      if (noteEl && st) {
        noteEl.textContent = `n=${st.n} · mean=${fmt(st.mean, 1)} · median=${fmt(q.med, 1)} · min=${fmt(st.min, 1)} · max=${fmt(st.max, 1)}.`;
      }
    }

    // ---------- simple categorical bar chart (counts) ----------
    function drawCountBars(svgId, countsObj, titleLabel, noteId) {
      const svg = document.getElementById(svgId);
      if (!svg) return;
      clearSvg(svg);

      const W = 760, H = 520;
      const pad = { l: 60, r: 20, t: 20, b: 54 };
      const plotW = W - pad.l - pad.r;
      const plotH = H - pad.t - pad.b;

      const labels = Object.keys(countsObj);
      const values = labels.map(k => countsObj[k]);
      const maxV = Math.max(...values, 1);

      // grid lines
      const ticks = 4;
      for (let i = 0; i <= ticks; i++) {
        const v = (i / ticks) * maxV;
        const y = pad.t + (1 - v / maxV) * plotH;
        svg.appendChild(lineEl(pad.l, y, pad.l + plotW, y, { stroke: "#111827", w: 1 }));
        svg.appendChild(textEl(12, y + 4, `${Math.round(v)}`, { size: 11, fill: "#94a3b8" }));
      }

      svg.appendChild(textEl(pad.l, 14, titleLabel, { size: 12, fill: "#94a3b8" }));

      const step = plotW / labels.length;
      const barW = Math.min(140, step * 0.6);

      labels.forEach((lab, i) => {
        const v = countsObj[lab];
        const x = pad.l + step * i + step / 2;
        const y0 = pad.t + plotH;
        const yV = pad.t + (1 - v / maxV) * plotH;

        svg.appendChild(rectEl(x - barW/2, yV, barW, Math.max(2, y0 - yV), {
          fill: "rgba(79,70,229,0.22)",
          stroke: "#4f46e5",
          sw: 2,
          rx: 12,
          ry: 12
        }));

        svg.appendChild(textEl(x, yV - 8, `${v}`, { anchor: "middle", size: 12, fill: "#e5e7eb", weight: "600" }));
        svg.appendChild(textEl(x, H - 22, lab, { anchor: "middle", size: 12, fill: "#cbd5e1" }));
      });

      const noteEl = document.getElementById(noteId);
      if (noteEl) noteEl.textContent = `Total responses: ${values.reduce((a,b)=>a+b,0)}.`;
    }

    // ---------- participant bar chart (numeric per participant) ----------
    function drawParticipantBars(svgId, participants, valueKey, labelKey, titleLabel, noteId) {
      const svg = document.getElementById(svgId);
      if (!svg) return;
      clearSvg(svg);

      const W = 760, H = 280;
      const pad = { l: 60, r: 20, t: 20, b: 54 };
      const plotW = W - pad.l - pad.r;
      const plotH = H - pad.t - pad.b;

      const labels = participants.map(p => p[labelKey]);
      const values = participants.map(p => Number(p[valueKey])).filter(x => !Number.isNaN(x));
      const maxV = Math.max(...values, 1);
      const minV = Math.min(...values, 0);
      const range = (maxV - minV) || 1;

      // y domain with margin
      const minA = minV - range * 0.05;
      const maxA = maxV + range * 0.05;

      const yScale = (v) => pad.t + (1 - (v - minA) / (maxA - minA)) * plotH;

      // grid
      const ticks = 5;
      for (let i = 0; i <= ticks; i++) {
        const v = minA + (i / ticks) * (maxA - minA);
        const y = yScale(v);
        svg.appendChild(lineEl(pad.l, y, pad.l + plotW, y, { stroke: "#111827", w: 1 }));
        svg.appendChild(textEl(10, y + 4, fmt(v, 0), { size: 11, fill: "#94a3b8" }));
      }

      svg.appendChild(textEl(pad.l, 14, titleLabel, { size: 12, fill: "#94a3b8" }));

      const step = plotW / labels.length;
      const barW = Math.min(90, step * 0.6);

      participants.forEach((p, i) => {
        const v = Number(p[valueKey]);
        const x = pad.l + step * i + step / 2;
        const y0 = yScale(minA);
        const yV = yScale(v);

        svg.appendChild(rectEl(x - barW/2, yV, barW, Math.max(2, y0 - yV), {
          fill: "rgba(79,70,229,0.22)",
          stroke: "#4f46e5",
          sw: 2,
          rx: 12,
          ry: 12
        }));

        svg.appendChild(textEl(x, yV - 8, `${v}`, { anchor: "middle", size: 12, fill: "#e5e7eb", weight: "600" }));
        svg.appendChild(textEl(x, H - 22, p[labelKey], { anchor: "middle", size: 12, fill: "#cbd5e1" }));
      });

      const noteEl = document.getElementById(noteId);
      if (noteEl) {
        const st = stats(participants.map(p => p[valueKey]));
        noteEl.textContent = st ? `mean=${fmt(st.mean, 1)} · min=${fmt(st.min, 0)} · max=${fmt(st.max, 0)}.` : "";
      }
    }

    // ---------- render table + excerpts ----------
    function renderSummaryTable() {
      const tbody = document.getElementById("summary-table-body");
      if (!tbody) return;
      tbody.innerHTML = "";
      participants.forEach(p => {
        const tr = document.createElement("tr");
        tr.innerHTML = `
          <td>${p.pid}</td>
          <td>${p.gender}</td>
          <td>${p.age}</td>
          <td>${p.appStructure}</td>
          <td>${p.puzzleAppropriate.toUpperCase()}</td>
          <td>${fmt(p.susScore, 1)}</td>
        `;
        tbody.appendChild(tr);
      });
    }

    function renderFeedbackExcerpts() {
      const ul = document.getElementById("feedback-excerpts");
      if (!ul) return;
      ul.innerHTML = "";

      // pick the most “useful” / distinct excerpts from the open question
      const excerpts = participants
        .map(p => p.firstLook)
        .filter(Boolean);

      // Keep unique, keep order
      const unique = [];
      excerpts.forEach(x => {
        const norm = x.trim().toLowerCase();
        if (!unique.some(u => u.trim().toLowerCase() === norm)) unique.push(x.trim());
      });

      // Show up to 5
      unique.slice(0, 5).forEach(x => {
        const li = document.createElement("li");
        li.textContent = `“${x}”`;
        ul.appendChild(li);
      });

      if (!unique.length) {
        const li = document.createElement("li");
        li.className = "muted";
        li.textContent = "TODO: Add relevant feedback excerpts.";
        ul.appendChild(li);
      }
    }

    function setDemographicsSummary() {
      const countEl = document.getElementById("participants-count");
      const genderEl = document.getElementById("participants-gender");
      const ageEl = document.getElementById("participants-age");

      const n = participants.length;
      const genders = {};
      participants.forEach(p => { genders[p.gender] = (genders[p.gender] || 0) + 1; });

      const ages = participants.map(p => p.age);
      const ageStats = stats(ages);

      if (countEl) countEl.textContent = `${n}`;
      if (genderEl) genderEl.textContent = Object.entries(genders).map(([g,c]) => `${g}: ${c}`).join(", ");
      if (ageEl && ageStats) ageEl.textContent = `mean ${fmt(ageStats.mean,1)}, min ${ageStats.min}, max ${ageStats.max}`;
    }

    // ---------- init ----------
    (function init() {
      setDemographicsSummary();
      renderSummaryTable();
      renderFeedbackExcerpts();

      // Boxplots
      drawSingleBoxplot(
        "svg-box-sus",
        participants.map(p => p.susScore),
        "SUS (0–100)",
        "note-box-sus",
        [0, 100]
      );

      drawSingleBoxplot(
        "svg-box-structure",
        participants.map(p => p.appStructure),
        "App Structure (1–5)",
        "note-box-structure",
        [1, 5]
      );

      // Counts: puzzle appropriate
      const puzzleCounts = { Yes: 0, No: 0 };
      participants.forEach(p => {
        if ((p.puzzleAppropriate || "").toLowerCase().startsWith("y")) puzzleCounts.Yes++;
        else puzzleCounts.No++;
      });
      drawCountBars("svg-bar-puzzle", puzzleCounts, "Responses", "note-bar-puzzle");

      // Ages (by participant)
      drawParticipantBars("svg-bar-age", participants, "age", "pid", "Age", "note-bar-age");
    })();
  </script>

</body>
</html>
